[中文文档](README_zh.md)
## Requirements
Implement a high-concurrency balance transaction service:
Each transaction includes a unique transaction ID, source account number, target account number, transaction amount, and timestamp. The transaction ID does not need to be generated by the service. Each transaction requires updating the balances of both the source account and the target account.
Each request contains one transaction and needs to return results in real time.
It is necessary to ensure data consistency, support high concurrency, and enable retries.

## Architecture
Technology selection: springboot + springJPA + postgreSQL + redis
Design principles: Consistency, high performance
Deployment: Deployed on Alibaba Cloud K8S and exposed to the outside world through the service

## Design Scheme
### Consistency
Since this is a requirement for a financial scenario, strong consistency is needed.
A single transaction requires reading and writing to the account table and the transaction table, and database transactions need to be used (distributed transactions are not considered for now).
There are two schemes available: the pessimistic locking scheme and the optimistic locking scheme:
Scheme 1: Pessimistic locking. Use `select for update` to lock a single row, which is equivalent to adding an exclusive lock throughout the entire transaction until the transaction ends.
```
begin
select balance ,version from account where id=?  for update   // Read the source account and lock it until the transaction ends  
select balance ,version from account where id=?  for update   // Read the target account and lock it until the transaction ends
update account set balance = ? where id= ?   // Update the source account    
update account set balance = ? where id= ?   // Update the target account    
commit  
```
Scheme 2: Optimistic locking.
Add a `version` field to the account table. Check whether the version number is correct each time an update is made. If it is incorrect, the update fails and waits for a retry.
No exclusive lock is added when reading the table, and concurrency is allowed. An exclusive lock is only added when updating, reducing the duration of holding the lock.
```
begin
select balance ,version from account where id=? // Read the source account  
select balance ,version from account where id=?  // Read the target account  
balance = balance +amount  // Calculate the updated value  
update account set balance = ?  version= ? where id= ? and version=?   // Update the source account  
update account set balance = ? version= ?  where id= ? and version=?   // Update the target account  
commit    
```
Both of these schemes are viable, and the choice should be based on the actual scenario. If there is a high probability of concurrency for the same account, leading to easy conflicts, it is recommended to choose the pessimistic locking scheme. Here, we choose the optimistic locking scheme.

### Retry + Idempotency Design
Since conflicts may occur with optimistic locking, automatic retries with retry support are required, and retries need to support idempotency.
Use the `@Retryable` annotation to implement automatic retries. To support idempotency, it is necessary to check whether the transaction ID already exists each time.
To improve performance, write the transaction ID to Redis. First, set an expiration time of 30 seconds.
Register a transaction synchronization processor. If the transaction is committed successfully, change the expiration time to 1 day; if it is rolled back, delete the transaction ID.

### Deadlock Prevention Design
A single transaction requires updating two accounts. If Thread 1 updates Account A first and then Account B, and Thread 2 updates Account B first and then Account A, a deadlock is likely to occur. Therefore, when updating accounts, they need to be sorted and updated in ascending or descending order.

## Deployment:
1. Activate the Container Service ACK on Alibaba Cloud, with 2 business nodes. Among them, Node 1 activates an EIP for convenient remote login.
2. Activate the Cloud Database PostgreSQL and Cloud Redis on Alibaba Cloud, and create the corresponding accounts and databases.
3. Log in to Node 1, install `kubectl`, obtain the `kubeconfig` file from the Alibaba Cloud console, and copy it to the `$HOME/.kube/config` file directory of the node.
4. Refresh the `configmap.yml` file in the `deploy` directory according to the information of PostgreSQL and Redis.
5. Upload the `deploy` directory to Node 1 and execute the commands to create the configmap and service resources:
   ```
   kubectl apply -f configmap.yml  
   kubectl apply -f deployment.yml  
   kubectl apply -f service.yml  
   ```
   Execute the `curl` command to check if the interface is working properly:
   ```
   curl --request POST 'http://IP:8090/transactions' \
   --header 'Content-Type: application/json' \
   --data-raw '{
   "sourceAccountNumber": "1001",
   "targetAccountNumber": "1002",
   "amount": 10.0,
   "transactionId":"110"
   }'
   ```

### Compilation and Packaging
```
mvn package -DskipTests=true  
```
Local Execution:
```
mvn spring-boot:run  
```

### Testing
Execute Unit Tests:
```
mvn test -Dtest=com.wpy.transaction.llt.*Test  
```
Execute Integration Tests: First, start the service, and then execute:
```
mvn test -Dtest=com.wpy.transaction.hlt.*Test  
```
Execute Performance Tests:
Download the `test.jmx` file in the `tools` directory and run JMeter.
The test report is located in the `doc` directory. 